package Riap; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Rinci access protocol

=head1 SPECIFICATION VERSION

 1.1


=head1 ABSTRACT

This document specifies a simple, extensible, client/server, request/response
protocol for requesting metadata and performing actions on code entities.

Examples are written in JSON (sometimes with added comments), but data
structures can actually be encoded using other formats.


=head1 STATUS

The 1.1 series does not guarantee full backward compatibility between revisions,
so caveat implementor. However, major incompatibility will bump the version to
1.2 or 2.0.


=head1 DESCRIPTION

Rinci access protocol (Riap for short), is a client/server, request/response
protocol for requesting metadata and performing actions on code entities. It is
modeled closely after HTTP, but is a different protocol. It can be layered on
top of HTTP (as its transport protocol) but can also use other transports,
including direct TCP. L<Riap::HTTP> explains how Riap can be used over HTTP.

The server side is viewed as being a tree of code entities, with a package
entity at the root. Other entities (such as subpackages, functions, variables)
are discoverable by performing C<list> actions on package entities. Entity's
metadata can be retrieved using the C<meta> action. There are other actions
defined in the specification; and the protocol can be extended by introducing
more actions.


=head1 TERMINOLOGIES

=over 4

=item * Server

=item * Client

=item * Response

Response is an enveloped result as defined in the L<Rinci::function>
specification.

=item * Request

A Riap request is modelled after HTTP request. It consists of an action
(analogous to HTTP request method), code entity URI, protocol version, and zero
or more extra arguments (analogous to HTTP headers). Some extra arguments might
be required, depending on the action.

For simplicity, the request can be expressed as a hash (or dictionary) of
key/value pairs. There should at least be these keys: C<action>, C<uri>, and
C<v> (for protocol version). This also means the extra arguments cannot have
those names. They must also start with letters or underscores followed by zero
or more letters/underscores/digits.

Server should return 400 status if required keys are missing, unknown keys are
sent, or keys contain invalid values.

=back


=head1 RIAP URI SCHEME

To refer to code entities, a new URI scheme C<riap> is defined. URI scheme can
be suffixed with transport, e.g. C<riap+tcp> for Riap over direct TCP (see
L<Riap::TCP>) or C<riap+http>/C<riap+https> for Riap over HTTP/HTTPS (see
L<Riap::HTTP>).

Without transport, the host part of URI can be used to refer to host language.
For example:

 # refer to Text::sprintfn module
 riap://perl/Text/sprintfn/

 # refer to sprintf function in Text::sprintfn
 riap://perl/Text/sprintfn/sprintfn

 # refer to PHP variable
 riap://php/$var

 # UNDECIDED: refer to class metadata
 riap://perl/My/Class/:class

 # UNDECIDED: refer to distribution metadata
 riap://perl/My/Dist/:distribution

Scheme/host and parts of path are optional if you refer from the same host
language or module. Examples:

 # refer to Text::sprintfn module from another Perl module
 /Text/sprintfn/

 # refer to Text::Wrap module from Text::sprintfn
 ../Wrap/

If transport is used, host (and port) means network host (and port) as usual:

 riap+tcp://localhost:7001/Foo/bar
 riap+http://gudangapi.com/tax/id/npwp/validate_npwp

Lest there is confusion, with Riap over HTTP/HTTPS there is also the
C<http>/C<https> URLs to access the services. The URI path for these do not
necessarily map directly to code entities like in C<riap> URIs, they may also
support additional features, as each service provider can choose custom URL
layout. Example:

 # access tax::id::validate_npwp function, call with arguments
 http://gudangapi.com/ga/tax.id.npwp/validate_npwp?npwp=123456

 # namespace/module can also be omitted when function name is unique. arguments
 # can also be specified by position
 http://gudangapi.com/ga/validate_npwp/123456


=head1 THE REQUEST

As mentioned previously, the Riap request is a mapping of request keys and their
values. Some request keys:

=over 4

=item * v => FLOAT

Specify Riap protocol version. If not specified, default is C<1.1>. Server
should return 502 status if it does not support requested protocol version.

=item * uri => STR

Required. Specify the location to code entity. It is either a schemeless URI
(e.g. C</Package/SubPackage/func>) to refer to "local" code entity or URI with a
scheme to refer to a remote entity, e.g. C<http://example.org/api/Foo/Bar/func>,
in which case the server can decide to proxy it for the client or not.

The server should return 404 status if B<uri> does not map to an existing code
entity, or 403 if C<uri> is forbidden.

=item * action => STR

Required. Specify action to perform on the code entity.

The server should return 502 status if an action is unknown for the specified
URI. The server should return 401/403 status if authentication is required or
action is not allowed for the specified code entity, respectively.

=back

Additional keys might be recognized and/or required according to the action.


=head1 COMMON ACTIONS

Below are the actions which can be implemented by the server. Server can choose
to not implement any action, or implement additional actions. But for actions
mentioned below, the specification must be followed.

=head2 Action: B<info>

Get general information and information about the code entity. This action
requires no additional request keys. Upon success, the server must return a hash
result with at least the following keys (remember that the result is actually
enveloped with a 200 status):

 [200,"OK",
  {
   // server's protocol version
   "v": 1.1,

   // entity's type
   "type": "function",

   // canonical URI for the entity
   "uri": "/Package/SubPkg/",
  }
 ]

Server may add additional information keys. Transport specification like
L<Riap::TCP> or L<Riap::HTTP> might require additional keys.

=head2 Action: B<actions>

List available actions for code entity. The server should return a list of
action names:

 [200,"OK",
  ["info","actions","meta","call","complete_arg_val"]
 ]

Additional request key: B<detail> (bool, optional, default false, can be set to
true to make server return a list of records instead).

Under B<detail>, server should return something like this:

 [200,"OK",
  [
   {"name":"info", "summary":"Get general information about code entity"},
   {"name":"actions","summary":"List available actions for code entity"},
   {"name":"meta","summary":"Get metadata for code entity"},
   {"name":"call","summary":"Call function"},
   {"name":"complete_arg_val","summary":"Complete function's argument value"}
  ]
 ]

It can return additional field like C<keys> to explain additional
required/optional request keys (XXX not yet specified).

=head2 Action: B<meta>

Return Rinci metadata for the code entity. When the entity does not have
metadata, server should return 404 status or better yet 534 (metadata not
found).


=head1 ACTIONS FOR C<package> ENTITIES

Below are actions that must be supported by the C<package> entities.

=head2 Action: B<list>

List entities contained in this package. Additional request keys are: B<type>
(string, optional, to limit only listing entities of a certain type; default is
undef which means list all kinds of entities), B<recursive> (bool, optional, can
be set to true to search subpackages; default is false which means only list
entities in this namespace), B<q> (string, search terms, to only return matching
some search terms; default is undef which means return all entities), B<detail>
(bool, optional, whether to return just a list of code entity URIs or a detailed
record for each entry, defaults to false; if true, then server must return info
hash for each entry, where each info hash like that returned by the C<info>
action).

The server should return 200 status or 206 if partial list is returned. If
B<detail> is true, for each entry a hash must be returned containing at least
B<uri> and B<type>. Server may add additional information like B<summary>,
B<description>, etc.

Example, a C<list> action on the top namespace C</> might return the following:

 [200,"OK",
  ["pm:///Math","pm:///Utils"]
 ]

Another example, a C<list> action on the C<pm:///Math> namespace, with C<type>
set to C<function> and C<q> to C<multiply>, and C<detail> set to true:

 [200,"OK",
  [
   {"uri": "pm:///Math/multiply2",
    "type": "function",
    "summary": "Multiply two numbers"},

   {"uri": "pm:///Math/multmany",
    "type": "function",
    "summary": "Multiply several numbers"}
  ]
 ]

=head2 Action: B<child_metas>

Get metadata for all the children entities of the package entity.

This action can reduce the number of round-trips, as opposed to client
performing C<list> action followed by C<meta> for each child.

Example, an C<child_metas> action on the top namespace C</> might return the
following:

 [200,"OK",
  {
   "pm:///Math":  {"v":1.1, "summary":"This is metadata for Math"},
  ,"pm:///Utils": {"v":1.1, "summary":"This is metadata for Utils"}
  }
 ]


=head1 ACTIONS FOR C<function> ENTITIES

Below are actions that are available for the C<function> entities. At least
C<call> must be implemented by the server.

=head2 Action: B<call>

Call a function and return its result. Additional request keys include:

=over 4

=item * B<args>

Hash, optional, function arguments, defaults to C<{}>.

=back

=head2 Action: B<complete_arg_val>

Complete function argument value, a la Bash tab completion where you have a
semicompleted word and request possible values started by that word. Additional
Riap request keys include:

=over 4

=item * B<arg>

String, required, the name of function argument to complete.

=item * B<word>

String, optional, word that needs to be completed. Defaults to empty string.

=back

The server should return a list of possible completions. Example, when
completing a C<delete_user> function for the argument C<username>, and C<word>
is "st", the server might return:

 [200,"OK",
  ["stella","steven","stuart"]
 ]

When there is no completion, the server should return an empty list:

 [200,"OK",
  []
 ]


=head1 FAQ

=head2 Why no actions to modify metadata/code entities?

Since the specification is extensible by adding more actions, you can implement
this on your system. These actions are not specified by this specification
because currently the main goal of the protocol is to provide API service and
read-only access to the metadata.

Alternatively, modifying metada/code entities can be implemented using calls to
functions on the server which can perform the modifications.

There are also some issues which need to be considered when adding these
actions. First of all, security. Second, you need to decide whether to modify
the running/in-memory copy or the actual source code/files (as the code entities
are usually stored as). When modifying the in-memory copy, the server-side
architecture may have multiple copies (multiple processes and machines). Do you
want to modify all those copies or just one the one process?

=head2 The name?

B<Riap> stands for Rinci access protocol, but it is also an Indonesian word
meaning: to gain in size or number.


=head1 HISTORY

=head2 1.1 (Jan 2012)

Rename specification to Riap. Version bumped to 1.1 to various
backward-incompatible adjustments to Rinci's terminologies.

=head2 1.0 (Aug 2011)

Split specification to L<Sub::Spec::HTTP>.

=head2 May 2011

First release of L<Sub::Spec::HTTP::Server>.


=head1 SEE ALSO

L<Rinci>

B<SOAP, WSDL>. Popular in the early 2000's, with similar goals (easier service
discovery, "simple" request/response protocol which can utilize HTTP or other
transport layer). Fell out of favor along with the rise of JavaScript and REST
and increased criticism against the complexity of XML. Which is ironic because
SOAP was originally created to be the simpler alternative to CORBA.

B<CORBA>.

=cut
